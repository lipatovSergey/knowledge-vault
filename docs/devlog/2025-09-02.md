## 2025-08-28 — Password reset (Step 6): decouple from tokenStore in expiry tests

**Feature goal:**  
Stop relying on direct access to `tokenStore` inside tests when simulating token expiry. Make time manipulation testable without touching internal storage.

### Problem

- Initial approach: mutate `tokenStore.get(email).createdAt` directly.
- Tried `jest.useFakeTimers()`, but it conflicted with `express-session` and caused hanging tests.
- Overriding `Date.now` globally also led to instability.

### Solution

1. Introduced a **time utility wrapper**:

   ```js
   let getNow = () => Date.now();

   function now() {
     return getNow();
   }
   function __setNowForTests(fn) {
     getNow = fn;
   }
   function __resetNowForTests() {
     getNow = () => Date.now();
   }

   module.exports = { now, __setNowForTests, __resetNowForTests };
   ```

```

```

2. Updated `auth.service` to use `now()` instead of `Date.now()`:

   ```js
   if (now() - inMemoryToken.createdAt > RESET_TOKEN_TTL_MS) {
     tokenStore.remove(data.email);
     throw new BadRequestError("Invalid or expired token");
   }
   ```

3. In tests, override `now` instead of mutating the store:

   ```js
   const fakeNow = tokenInMemory.createdAt + RESET_TOKEN_TTL_MS + 1;
   __setNowForTests(() => fakeNow);
   const res = await agent.post(route).send({ ... });
   expect(res.statusCode).toBe(400);
   __resetNowForTests();
   ```

4. Final refinement: stop using `tokenStore` in tests altogether.
   Instead, extract `createdAt` from the **reset email**:

   ```js
   const message = mailbox.lastTo(email);
   const emailTime = message.createdAt.getTime();
   const fakeNow = emailTime + RESET_TOKEN_TTL_MS + 100;
   __setNowForTests(() => fakeNow);
   ```

✅ Result: Tests simulate token expiry based on email timestamps, no direct dependency on internal `tokenStore`.

---

## 2025-08-28 — Password reset (Step 7): align error responses with security rules

**Feature goal:**  
Clarify which endpoints should return neutral `204` vs error `400`.

### Insight

- `/auth/password/forgot` must always return `204 No Content` (neutral), regardless of whether the email exists → prevents email enumeration.
- `/auth/password/reset` should return **`400 Bad Request`** for all token validation failures, since the reset flow is tied to an explicit token.

### Change

- Rolled back controller logic for `resetPassword` to always propagate `BadRequestError` as `400`.
- Updated related tests: previously expected `204` for expired/invalid tokens, now expect `400`.

**Controller snippet**

```js
async resetPassword(req, res, next) {
  try {
    const body = req.validatedData;
    await authServices.checkTokens(body);
    await userServices.updateUserPassword(body.email, body.newPassword, userRepo);
    tokenStore.remove(body.email);
    await destroySession(req);
    return res.status(204).end();
  } catch (err) {
    next(err); // let BadRequestError surface as 400
  }
}
```

✅ Result:

- **Forgot password** → always `204`.
- **Password reset** → `400` for any token mismatch/expiry/format error.
- Consistent, security-focused response model across endpoints.
